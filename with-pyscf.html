<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>DMRG for electronic structure calculations &mdash; BLOCK 1.5.0 documentation</title>
    
    <link rel="stylesheet" href="static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.5.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="BLOCK 1.5.0 documentation" href="index.html" />
    <link rel="next" title="Block program as a standalone solver" href="examples.html" />
    <link rel="prev" title="Block Installation" href="build.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="examples.html" title="Block program as a standalone solver"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="build.html" title="Block Installation"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">BLOCK 1.5.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">DMRG for electronic structure calculations</a><ul>
<li><a class="reference internal" href="#casci-casscf-in-pyscf">CASCI/CASSCF in PySCF</a></li>
<li><a class="reference internal" href="#setup-block-in-pyscf-package">Setup Block in PySCF package</a></li>
<li><a class="reference internal" href="#control-block-program-through-pyscf-wrapper">Control Block program through PySCF wrapper</a><ul>
<li><a class="reference internal" href="#parallelism">Parallelism</a></li>
<li><a class="reference internal" href="#bond-dimension-and-sweep-scheduler">Bond dimension and sweep scheduler</a></li>
<li><a class="reference internal" href="#dmrgci-functions-and-attributes">DMRGCI functions and attributes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#state-average-and-state-specific-dmrg-casci-dmrg-casscf">State-average and state-specific DMRG-CASCI/DMRG-CASSCF</a></li>
<li><a class="reference internal" href="#dmrg-nevpt2">DMRG-NEVPT2</a></li>
<li><a class="reference internal" href="#case-study">Case study</a></li>
<li><a class="reference internal" href="#run-block-standalone">Run Block standalone</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="build.html"
                        title="previous chapter">Block Installation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="examples.html"
                        title="next chapter">Block program as a standalone solver</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="sources/with-pyscf.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="dmrg-for-electronic-structure-calculations">
<span id="dmrg-pyscf"></span><h1>DMRG for electronic structure calculations<a class="headerlink" href="#dmrg-for-electronic-structure-calculations" title="Permalink to this headline">¶</a></h1>
<p>Block program supports two executing modes: running standalone through command
line or as a plugin of other quantum chemistry package.  The Python-based
quantum chemistry program package <a class="reference external" href="http://www.pyscf.org">PySCF</a> provides a
simple solution to run Block program.  It is the recommended way to use
Block program in most scenario.</p>
<p>In PySCF, DMRG program is mainly used as a replacement of Full CI solver for
large active space CASCI or CASSCF problem.  On top of DMRG-CASCI and
DMRG-CASSCF, MPS-PT can be called through Block-PySCF interface.  Using Block
with PySCF,  systems around 50-active-orbital DMRG-CASSCF or 30-active-orbital
MPSPT can be studied in a regular basis.</p>
<div class="section" id="casci-casscf-in-pyscf">
<h2>CASCI/CASSCF in PySCF<a class="headerlink" href="#casci-casscf-in-pyscf" title="Permalink to this headline">¶</a></h2>
<p>PySCF is a collection Python modules for electronic structure simulation
and theory developing.  In this section, we briefly review the usage of
PySCF.  More usage details of PySCF package can be found in PySCF online
documents <a class="reference external" href="http://www.pyscf.org">http://www.pyscf.org</a>.  If you have PySCF installed and setup
correctly (see <a class="reference external" href="http://www.pyscf.org/install.html">http://www.pyscf.org/install.html</a>), you can create a
Python script for CASCI and CASSCF calculation:</p>
<div class="highlight-python"><div class="highlight"><pre>$ cat c2_cas.py
from pyscf import gto, scf, mcscf
mol = gto.M(atom=&quot;N 0 0 0; N 0 0 1&quot;, basis=&quot;ccpvdz&quot;)
mf = scf.RHF(mol).run()
ncas = 6
nelec_cas = 6
mc = mcscf.CASCI(mf, ncas, nelec_cas)
mc.kernel()
mc = mcscf.CASSCF(mf, ncas, nelec_cas)
mc.kernel()
</pre></div>
</div>
<p>The Python script <tt class="file docutils literal"><span class="pre">c2_cas.py</span></tt> can be executed by Python interpreter in
command line:</p>
<div class="highlight-python"><div class="highlight"><pre>$ python c2_cas.py
converged SCF energy = -108.929838385609
CASCI E = -108.980200822148  E(CI) = -11.9360559617961  S^2 = 0.0000000
CASSCF energy = -109.044401900068
</pre></div>
</div>
<p>Based on the given active space size and number of correlated electrons, the
CASCI/CASSCF solver by default takes the highest occupied and lowest unoccupied
orbitals to form the active space.  To change the active space, you need prepare
a set of orbitals and reorder the orbitals to place the required active orbitals
in the HOMO and LUMO space.  You can feed the reordered orbitals to function
<tt class="docutils literal"><span class="pre">mc.kernel(orbs)</span></tt> as the initial guess.  CASCI/CASSCF solver will take the
&#8220;HOMO/LUMO&#8221; orbitals from <tt class="docutils literal"><span class="pre">orbs</span></tt> as the active space.  It is inconvenient to
prepare the active space through this selecting-then-reordering procedure.
To simplify this procedure, PySCF package provides some helper functions, such
as <tt class="xref py py-meth docutils literal"><span class="pre">sort_mo()</span></tt>, <tt class="xref py py-meth docutils literal"><span class="pre">sort_mo_by_irrep()</span></tt>, <tt class="xref py py-meth docutils literal"><span class="pre">dmet_cas.guess_cas()</span></tt>,
<tt class="xref py py-meth docutils literal"><span class="pre">atomic_valence()</span></tt> <a class="footnote-reference" href="#id3" id="id1">[1]</a>.
In the following example, we selected 4 <span class="math">\(\pi\)</span> orbitals and 1 <span class="math">\(\sigma\)</span>
orbital and 1 <span class="math">\(\sigma^*\)</span> orbital from mean-field molecular orbitals to
form the active space using the helper function <tt class="xref py py-meth docutils literal"><span class="pre">sort_mo_by_irrep()</span></tt>.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre> <span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
 <span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s">&quot;N 0 0 0; N 0 0 1&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s">&quot;ccpvdz&quot;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
 <span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

 <span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
 <span class="n">ncas_by_irreps</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;E1ux&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;E1uy&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;A1g&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;A1u&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
 <span class="n">orbs</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">sort_mo_by_irrep</span><span class="p">(</span><span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">ncas_by_irreps</span><span class="p">)</span>
 <span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span>
</pre></div>
</td></tr></table></div>
<p>In the above example, you should read the input as a Python program.  Line 2
creates a molecule and applied mean-field calculation on the molecule.  The
mean-field results are saved in <tt class="docutils literal"><span class="pre">mf</span></tt> object so that you can access them later.
For example, in line 5, HF MOs <tt class="docutils literal"><span class="pre">mf.mo_coeff</span></tt> are passed to function
<tt class="xref py py-meth docutils literal"><span class="pre">mc.sort_mo_by_irrep()</span></tt>.  <tt class="xref py py-meth docutils literal"><span class="pre">mc.sort_mo_by_irrep()</span></tt> read the configs from
<tt class="docutils literal"><span class="pre">ncas_by_irreps</span></tt> and return the reordered orbitals <tt class="docutils literal"><span class="pre">orbs</span></tt> which is then fed
to <tt class="xref py py-meth docutils literal"><span class="pre">mc.kernel()</span></tt> function as the initial guess.  <tt class="docutils literal"><span class="pre">mc</span></tt> is the CASSCF object
created by <tt class="docutils literal"><span class="pre">mcscf.CASSCF</span></tt> function.  More options can be specified for <tt class="docutils literal"><span class="pre">mc</span></tt>
object to control the calculation.  For example, you can set the convergence
tolerance <tt class="docutils literal"><span class="pre">mc.conv_tol</span> <span class="pre">=</span> <span class="pre">1e-6</span></tt>; require more computation details to be printed
in the output with <tt class="docutils literal"><span class="pre">mc.verbose=5</span></tt>; call <tt class="xref py py-func docutils literal"><span class="pre">mc.analyze()</span></tt> to print out the
population analysis of the CASCI/CASSCF results.  The FCI solver of CASCI/CASSCF
object is handled by the attribute <tt class="xref py py-attr docutils literal"><span class="pre">mc.fcisolver</span></tt>.  You can control the
number of roots to compute by setting <tt class="docutils literal"><span class="pre">mc.fcisolver.nroots</span> <span class="pre">=</span> <span class="pre">3</span></tt>, or change the
symmetry of the correlated wave function with <tt class="docutils literal"><span class="pre">mc.fcisolver.wfnsym</span> <span class="pre">=</span> <span class="pre">'A1u'</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s">&quot;N 0 0 0; N 0 0 1&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s">&quot;ccpvdz&quot;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">ncas_by_irreps</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;E1ux&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;E1uy&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;A1g&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;A1u&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
<span class="n">orbs</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">sort_mo_by_irrep</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">ncas_by_irreps</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">nroots</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">wfnsym</span> <span class="o">=</span> <span class="s">&#39;a1u&#39;</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">analyze</span><span class="p">()</span>
</pre></div>
</div>
<p>Replacing <tt class="xref py py-attr docutils literal"><span class="pre">mc.fcisolver</span></tt> with DMRG solver leads to the DMRG-CASCI and
DMRG-CASSCF methods.  But the rest of the input code should be the same to the
regular CASCI/CASSCF calculation.  You need the molecule and the mean-field
objects to create the DMRG-CASCI/DMRG-CASSCF object <tt class="docutils literal"><span class="pre">mc</span></tt>.  You can adjust the
parameters in <tt class="docutils literal"><span class="pre">mc</span></tt> object to control the DMRG-CASCI/DMRG-CASSCF calculation
and adjust DMRG configs through the <tt class="xref py py-attr docutils literal"><span class="pre">mc.fcisolver</span></tt> object.
More CASCI/CASSCF parameters are documented in <a class="reference external" href="http://www.pyscf.org/mcscf.html">http://www.pyscf.org/mcscf.html</a></p>
</div>
<div class="section" id="setup-block-in-pyscf-package">
<h2>Setup Block in PySCF package<a class="headerlink" href="#setup-block-in-pyscf-package" title="Permalink to this headline">¶</a></h2>
<p>First you need <a class="reference internal" href="build.html#build"><em>prepare the Block executable binary</em></a>.
You can either compile it from source code <a class="footnote-reference" href="#id4" id="id2">[2]</a> or download the
precompiled binary
<a class="reference external" href="http://www.sunqm.net/pyscf/files/bin/block.spin_adapted-1.5.0.gz">block.spin_adapted-1.5.0.gz</a>
(compiled with Boost-1.55, OpenMPI-1.10.3, MKL-11) and the MPI-disabled version
<a class="reference external" href="http://www.sunqm.net/pyscf/files/bin/block.spin_adapted-1.5.0-serial.gz">block.spin_adapted-1.5.0-serial.gz</a>
(compiled with Boost-1.55, MKL-11).
Next, you need setup the Block runtime environment in PySCF.  In the config file
<tt class="file docutils literal"><span class="pre">/path/to/pyscf/future/dmrgscf/settings.py</span></tt> (see also the template
<tt class="file docutils literal"><span class="pre">/path/to/pyscf/future/dmrgscf/settings.py.template</span></tt>), you need specify:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">BLOCKEXE</span> <span class="o">=</span> <span class="s">&quot;/path/to/Block/block.spin_adapted&quot;</span>
<span class="n">BLOCKEXE_COMPRESS_NEVPT</span> <span class="o">=</span> <span class="s">&quot;/path/to/serially/compiled/Block/block.spin_adapted&quot;</span>
<span class="n">BLOCKSCRATCHDIR</span> <span class="o">=</span> <span class="s">&quot;/path/to/scratch&quot;</span>
<span class="n">MPIPREFIX</span> <span class="o">=</span> <span class="s">&quot;mpirun&quot;</span>  <span class="c"># or srun for SLURM system</span>
</pre></div>
</div>
<p>You need at least set <tt class="docutils literal"><span class="pre">BLOCKEXE</span></tt> for DMRG-CASCI and DMRG-CASSCF methods.
<tt class="docutils literal"><span class="pre">BLOCKSCRATCHDIR</span></tt> is the directory where to store temporary data and the DMRG
wave function.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Usually, the size of DMRG wave function is very large.  Be sure that the disk
which <tt class="docutils literal"><span class="pre">BLOCKSCRATCHDIR</span></tt> pointed to has enough space.</p>
</div>
<p>In the input script, you can replace the <tt class="xref py py-attr docutils literal"><span class="pre">mc.fcisolver</span></tt> by
<a class="reference external" href="http://www.pyscf.org/dmrgscf.html#id1">DMRGCI</a> object to call Block program
in CASCI/CASSCF calculation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">dmrgscf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s">&quot;N 0 0 0; N 0 0 1&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s">&quot;ccpvdz&quot;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">ncas_by_irreps</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;E1ux&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;E1uy&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;A1g&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;A1u&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
<span class="n">orbs</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">sort_mo_by_irrep</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">ncas_by_irreps</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">nroots</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">wfnsym</span> <span class="o">=</span> <span class="s">&#39;a1u&#39;</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">analyze</span><span class="p">()</span>
</pre></div>
</div>
<p>Generally speaking, this simple replacement of <tt class="xref py py-attr docutils literal"><span class="pre">mc.fcisolver</span></tt> is enough to
call the DMRG-CASCI and DMRG-CASSCF methods in your calculation.  The rest
settings of the <tt class="docutils literal"><span class="pre">mc</span></tt> object are all the same to the regular CASCI/CASSCF.
When <tt class="xref py py-func docutils literal"><span class="pre">mc.kernel()</span></tt> is finished, the CASCI/CASSCF results such as orbital
coefficients, natural occupancy etc. are held in <tt class="docutils literal"><span class="pre">mc</span></tt> object.  But the DMRG
wave-function is not.  It is stored in the directory specified by the attribute
<tt class="docutils literal"><span class="pre">DMRGCI.scratchDirectory</span></tt> or <tt class="docutils literal"><span class="pre">BLOCKSCRATCHDIR</span></tt> (the default value) in
the config <tt class="file docutils literal"><span class="pre">pyscf/future/dmrgscf/settings.py</span></tt>.</p>
<p>To make the embedded DMRG solver work more efficiently in CASSCF optimization,
one needs carefully tune the DMRG parameters and dynamically update the
parameters during the CASSCF optimization.  It requires more codes in the
interface to let CASSCF and DMRG talk to each other.  We provided a shortcut
function <a class="reference internal" href="#DMRGSCF" title="DMRGSCF"><tt class="xref py py-func docutils literal"><span class="pre">DMRGSCF()</span></tt></a> in the <tt class="xref py py-mod docutils literal"><span class="pre">dmrgscf</span></tt> module to handle this
functionality:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">dmrgscf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s">&quot;N 0 0 0; N 0 0 1&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s">&quot;ccpvdz&quot;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">ncas_by_irreps</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;E1ux&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;E1uy&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#39;A1g&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="s">&#39;A1u&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}</span>
<span class="n">orbs</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">sort_mo_by_irrep</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">mf</span><span class="o">.</span><span class="n">mo_coeff</span><span class="p">,</span> <span class="n">ncas_by_irreps</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">wfnsym</span> <span class="o">=</span> <span class="s">&#39;a1u&#39;</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span>
</pre></div>
</div>
<p>We recommend to use <tt class="xref py py-func docutils literal"><span class="pre">dmrgscf.DMRGSCF()</span></tt> as the entry of DMRG-CASSCF method
whenever is possible.</p>
</div>
<div class="section" id="control-block-program-through-pyscf-wrapper">
<h2>Control Block program through PySCF wrapper<a class="headerlink" href="#control-block-program-through-pyscf-wrapper" title="Permalink to this headline">¶</a></h2>
<div class="section" id="parallelism">
<h3>Parallelism<a class="headerlink" href="#parallelism" title="Permalink to this headline">¶</a></h3>
<p>Block-1.1.1 or older version support MPI level parallelization.  The MPI
parallelization parameters are controlled by the variable <tt class="docutils literal"><span class="pre">MPIPREFIX</span></tt> in
<tt class="file docutils literal"><span class="pre">pyscf/future/dmrgscf/settings.py</span></tt> or the attribute <tt class="xref py py-attr docutils literal"><span class="pre">mpiprefix</span></tt> of
<a class="reference internal" href="#DMRGCI" title="DMRGCI"><tt class="xref py py-class docutils literal"><span class="pre">DMRGCI</span></tt></a> object.  For example, if you want to run Block using 4
processors on 2 nodes with Infiniband as the communication layer, you can
specify in the input script:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">mpiprefix</span> <span class="o">=</span> <span class="s">&#39;mpirun -np 4 -npernode --mca btl self,openib&#39;</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>If you are using <a class="reference external" href="https://www.open-mpi.org/faq/?category=slurm">SLURM</a> system
for job manager,  you can put <tt class="docutils literal"><span class="pre">MPIPREFIX</span> <span class="pre">=</span> <span class="pre">'srun'</span></tt> in the <tt class="file docutils literal"><span class="pre">settings.py</span></tt></p>
<p>To efficiently use memory, starting from Block-1.5, Block code introduces
threading level parallelism, more specifically, the OpenMP threading.  To enable
the multi-threading feature in Block, you need specify the attribute
<tt class="xref py py-attr docutils literal"><span class="pre">num_thrds</span></tt> in <a class="reference internal" href="#DMRGCI" title="DMRGCI"><tt class="xref py py-class docutils literal"><span class="pre">DMRGCI</span></tt></a> object to indicate the maximum number of
threads to be used by each MPI process:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">num_thrds</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>By default, Block code uses 1 thread in each process.  Using the multi-threading
with the multi-processing model (mpirun -np) potentially offers higher
performance and better scaling for DMRG parallelism.  It is recommended to
enable the multi-threading feature if your block program is newer than version
1.5.</p>
<p>On SLURM job system, the hybrid parallelism settings are controlled by
<a class="reference external" href="http://slurm.schedmd.com/sbatch.html#lbAG">SLURM runtime environment variables</a>.
You can control the parallel model by either configuring the resources through
the <tt class="docutils literal"><span class="pre">#SBATCH</span></tt> flags or setting the <tt class="docutils literal"><span class="pre">$SLURM_XXX</span></tt> variables in the SLURM
script.  For example, the following slurm script allocated in total 32 CPUs
which are distributed in 8 processes on 2 nodes:</p>
<div class="highlight-python"><div class="highlight"><pre>#SBATCH --nodes=2
#SBATCH --ntasks-per-node=4
#SBATCH --cpus-per-task=4

python c2_cas.py
</pre></div>
</div>
<p>Specifying <tt class="docutils literal"><span class="pre">mc.fcisolver.mpiprefix</span> <span class="pre">=</span> <span class="pre">'srun'</span></tt> will use SLURM to lanuch the
Block program which will be executed on 2 nodes with 4 processes on each node.
Note Block program does not detect the environment and setup the multi-threading
automatically.  You still need explicitly set <tt class="docutils literal"><span class="pre">mc.fcisolver.num_thrds</span> <span class="pre">=</span> <span class="pre">4</span></tt> in
the PySCF input script to turn on the multi-threading for Block program.</p>
</div>
<div class="section" id="bond-dimension-and-sweep-scheduler">
<h3>Bond dimension and sweep scheduler<a class="headerlink" href="#bond-dimension-and-sweep-scheduler" title="Permalink to this headline">¶</a></h3>
<p>Depending on the system, you may need change the DMRG bond dimension to improve
the accuracy or balance the accuracy and efficiency.  The default bond dimension
is 1000.  You can change the bond dimension by setting <tt class="xref py py-attr docutils literal"><span class="pre">fcisolver.maxM</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">dmrgscf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s">&quot;N 0 0 0; N 0 0 1&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s">&quot;ccpvdz&quot;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">maxM</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>Generally, other default scheduler implemented in the PySCF wrapper should work
fine in most systems.  You can adjust the sweep schedule through the
<a class="reference internal" href="#DMRGCI" title="DMRGCI"><tt class="xref py py-class docutils literal"><span class="pre">DMRGCI</span></tt></a> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dmrgsolver</span><span class="o">.</span><span class="n">scheduleSweeps</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">30</span><span class="p">]</span>
<span class="n">dmrgsolver</span><span class="o">.</span><span class="n">scheduleMaxMs</span>  <span class="o">=</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="mi">1200</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">,</span> <span class="mi">2000</span><span class="p">]</span>
<span class="n">dmrgsolver</span><span class="o">.</span><span class="n">scheduleTols</span>   <span class="o">=</span> <span class="p">[</span><span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">,</span> <span class="mf">1e-7</span><span class="p">]</span>
<span class="n">dmrgsolver</span><span class="o">.</span><span class="n">scheduleNoises</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
<span class="n">dmrgsolver</span><span class="o">.</span><span class="n">twodot_to_onedot</span> <span class="o">=</span> <span class="mi">34</span>
<span class="n">dmrgsolver</span><span class="o">.</span><span class="n">maxIter</span> <span class="o">=</span> <span class="mi">50</span>
</pre></div>
</div>
<p>The first four attributes which prefixed with <tt class="docutils literal"><span class="pre">schedule</span></tt> will be converted to
the <tt class="docutils literal"><span class="pre">schedule</span></tt> section in the Block config file:</p>
<div class="highlight-python"><div class="highlight"><pre>schedule
  0  200   0.0001  0.0001
  4  400   0.0001  0.0001
  8  800   0.0001  0.0001
  12 1200  0.0001  0.0001
  16 2000  1e-5    0.0001
  20 2000  1e-7    0.0001
  24 2000  1e-7    0.0
  30 2000  1e-7    0.0
end
</pre></div>
</div>
<p>In the early stage of Block sweep, the wave function is easy to stuck at local
minimum.  Although less efficient and accurate, applying the two-dot algorithm
can effectively help DMRG solver moving out of the local minimum.  Attribute
<tt class="xref py py-attr docutils literal"><span class="pre">twodot_to_onedot</span></tt> indicates when to switch to the one-dot algorithm which
is efficient and stable to converge.</p>
</div>
<div class="section" id="dmrgci-functions-and-attributes">
<h3>DMRGCI functions and attributes<a class="headerlink" href="#dmrgci-functions-and-attributes" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="DMRGCI">
<em class="property">class </em><tt class="descname">DMRGCI</tt><a class="headerlink" href="#DMRGCI" title="Permalink to this definition">¶</a></dt>
<dd><p>The interface of Block and PySCF.  The class exposes the Block keywords to
PySCF so that the Block code can be run and controlled in Python script.</p>
<dl class="attribute">
<dt id="DMRGCI.approx_maxIter">
<tt class="descname">approx_maxIter</tt><a class="headerlink" href="#DMRGCI.approx_maxIter" title="Permalink to this definition">¶</a></dt>
<dd><p>In 1-step DMRG-CASSCF algorithm, the number of sweeps during the approximate
FCI/DMRG updating.  Default is 4</p>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.block_extra_keyword">
<tt class="descname">block_extra_keyword</tt><a class="headerlink" href="#DMRGCI.block_extra_keyword" title="Permalink to this definition">¶</a></dt>
<dd><p>It allows you to input Block keywords which were not exposed in <a class="reference internal" href="#DMRGCI" title="DMRGCI"><tt class="xref py py-class docutils literal"><span class="pre">DMRGCI</span></tt></a>
class.  Some commonly used keywords include</p>
<blockquote>
<div><div class="line-block">
<div class="line">warmup local_2site</div>
<div class="line">nonspinadapted</div>
<div class="line">fiedler</div>
</div>
</div></blockquote>
<p>See <a class="reference internal" href="keywords.html#keywords-list"><em>Keywords</em></a> for the details of Block code keywords</p>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.configFile">
<tt class="descname">configFile</tt><a class="headerlink" href="#DMRGCI.configFile" title="Permalink to this definition">¶</a></dt>
<dd><p>By default, keywords are written to file dmrg.conf</p>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.dmrg_switch_tol">
<tt class="descname">dmrg_switch_tol</tt><a class="headerlink" href="#DMRGCI.dmrg_switch_tol" title="Permalink to this definition">¶</a></dt>
<dd><p>In 1-step DMRG-CASSCF, when the orbital gradients is smaller than this
value, the DMRG calculation starts to read the solution from previous step
as the initial guess (to reduce the computational cost).  Default is 1e-3.</p>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.executable">
<tt class="descname">executable</tt><a class="headerlink" href="#DMRGCI.executable" title="Permalink to this definition">¶</a></dt>
<dd><p>Default is settings.BLOCKEXE</p>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.integralFile">
<tt class="descname">integralFile</tt><a class="headerlink" href="#DMRGCI.integralFile" title="Permalink to this definition">¶</a></dt>
<dd><p>The file to store FCIDUMP.  Default is FCIDUMP</p>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.maxIter">
<tt class="descname">maxIter</tt><a class="headerlink" href="#DMRGCI.maxIter" title="Permalink to this definition">¶</a></dt>
<dd><p>Max number of sweeps</p>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.memory">
<tt class="descname">memory</tt><a class="headerlink" href="#DMRGCI.memory" title="Permalink to this definition">¶</a></dt>
<dd><p>The maximum memory (in GB) to use.  Default is 2 GB.  When you enabled multi
threading and had large bond dimensions <tt class="xref py py-attr docutils literal"><span class="pre">maxM</span></tt>, you might need
more memory to hold the intermediates.  Generally, large memory is helpful
to improve efficiency.</p>
<div class="versionadded">
<p><span class="versionmodified">New in version Block-1.5: </span>(stackblock)</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.mpiprefix">
<tt class="descname">mpiprefix</tt><a class="headerlink" href="#DMRGCI.mpiprefix" title="Permalink to this definition">¶</a></dt>
<dd><p>Default is settings.MPIPREFIX</p>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.nroots">
<tt class="descname">nroots</tt><a class="headerlink" href="#DMRGCI.nroots" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of states to solver simultaneously.</p>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.num_thrds">
<tt class="descname">num_thrds</tt><a class="headerlink" href="#DMRGCI.num_thrds" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of OpenMP threads to be used in each MPI process.  Default is 1.</p>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.outputFile">
<tt class="descname">outputFile</tt><a class="headerlink" href="#DMRGCI.outputFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Block output.  Default is dmrg.out</p>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.outputlevel">
<tt class="descname">outputlevel</tt><a class="headerlink" href="#DMRGCI.outputlevel" title="Permalink to this definition">¶</a></dt>
<dd><p>0 (less output) to 3 (very noise).  Default is 2.</p>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.restart">
<tt class="descname">restart</tt><a class="headerlink" href="#DMRGCI.restart" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether to read the wave function from the temporary directory (specified by
<a class="reference internal" href="#DMRGCI.scratchDirectory" title="DMRGCI.scratchDirectory"><tt class="xref py py-attr docutils literal"><span class="pre">scratchDirectory</span></tt></a>) as the initial guess.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Block code does not check whether the system of the existed wave funciton
matches the one in study.  A mismatched DMRG wave function (from wrong
<a class="reference internal" href="#DMRGCI.scratchDirectory" title="DMRGCI.scratchDirectory"><tt class="xref py py-attr docutils literal"><span class="pre">DMRGCI.scratchDirectory</span></tt></a>) may lead to wrong solution or cause
DMRG program crash.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.runtimeDir">
<tt class="descname">runtimeDir</tt><a class="headerlink" href="#DMRGCI.runtimeDir" title="Permalink to this definition">¶</a></dt>
<dd><p>Where to put files dmrg.conf, dmrg.out etc temporarily.  Default is current
directory (where you execute python).</p>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.scratchDirectory">
<tt class="descname">scratchDirectory</tt><a class="headerlink" href="#DMRGCI.scratchDirectory" title="Permalink to this definition">¶</a></dt>
<dd><p>The directory where to store the intermediates and wave functions.  Default
is settings.BLOCKSCRATCHDIR.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Be sure <tt class="docutils literal"><span class="pre">mc.fcisolver.scratchDirectory</span></tt> is properly assigned.
Since all DMRGCI object by default uses the same <tt class="docutils literal"><span class="pre">BLOCKSCRATCHDIR</span></tt> settings,
it&#8217;s easy to cause name conflicts on the scratch directory, especially when
two DMRG-CASSCF calculations are run on the same node.</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.spin">
<tt class="descname">spin</tt><a class="headerlink" href="#DMRGCI.spin" title="Permalink to this definition">¶</a></dt>
<dd><p>2S (= nelec_alpha - nelec_beta).  If the argument <tt class="docutils literal"><span class="pre">nelec</span></tt> of
<a class="reference internal" href="#DMRGCI.kernel" title="DMRGCI.kernel"><tt class="xref py py-meth docutils literal"><span class="pre">DMRGCI.kernel()</span></tt></a> function is a two-item list to represent the number of
alpha and beta electrons, the Block program will use the given alpha and
beta electron numbers to determine the spin.  Otherwise, Block program
takes this value as the spin of the system.</p>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.twodot_to_onedot">
<tt class="descname">twodot_to_onedot</tt><a class="headerlink" href="#DMRGCI.twodot_to_onedot" title="Permalink to this definition">¶</a></dt>
<dd><p>When to switch to one-dot algorithm.</p>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.weights">
<tt class="descname">weights</tt><a class="headerlink" href="#DMRGCI.weights" title="Permalink to this definition">¶</a></dt>
<dd><p>In state average calculation, the weight assocated to each state.</p>
</dd></dl>

<dl class="attribute">
<dt id="DMRGCI.wfnsym">
<tt class="descname">wfnsym</tt><a class="headerlink" href="#DMRGCI.wfnsym" title="Permalink to this definition">¶</a></dt>
<dd><p>In the DMRGCI interface, the wave function symmetry ID follows the PySCF
convention (see <a class="reference external" href="http://www.pyscf.org/symm.html">http://www.pyscf.org/symm.html</a>).  But Block code follows
Molpro convention.  A mapping between two symmetry ID is invoked in the
DMRGCI initialization function.  It is recommended to put the label of wave
function  (such as &#8216;A1g&#8217;, &#8216;B2u&#8217;) here to avoid the ambiguity.</p>
</dd></dl>

<dl class="method">
<dt id="DMRGCI.make_rdm1">
<tt class="descname">make_rdm1</tt><big>(</big><em>state</em>, <em>norb</em>, <em>nelec</em><big>)</big><a class="headerlink" href="#DMRGCI.make_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Given state ID, read its 1-particle density matrix from the directory
indicated by <a class="reference internal" href="#DMRGCI.scratchDirectory" title="DMRGCI.scratchDirectory"><tt class="xref py py-attr docutils literal"><span class="pre">scratchDirectory</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="DMRGCI.make_rdm12">
<tt class="descname">make_rdm12</tt><big>(</big><em>state</em>, <em>norb</em>, <em>nelec</em><big>)</big><a class="headerlink" href="#DMRGCI.make_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Given state ID, read its 1-particle and 2-particle density matrices from the
directory indicated by <a class="reference internal" href="#DMRGCI.scratchDirectory" title="DMRGCI.scratchDirectory"><tt class="xref py py-attr docutils literal"><span class="pre">scratchDirectory</span></tt></a>.  Note the 2-particle
density matrix is reordered to match the 2e integrals of chemists&#8217; notation,
dm2[p,q,r,s] <span class="math">\(= \langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="DMRGCI.make_rdm123">
<tt class="descname">make_rdm123</tt><big>(</big><em>state</em>, <em>norb</em>, <em>nelec</em><big>)</big><a class="headerlink" href="#DMRGCI.make_rdm123" title="Permalink to this definition">¶</a></dt>
<dd><p>Given state ID, read 1, 2 and 3-particle density matrices from the
directory indicated by <a class="reference internal" href="#DMRGCI.scratchDirectory" title="DMRGCI.scratchDirectory"><tt class="xref py py-attr docutils literal"><span class="pre">scratchDirectory</span></tt></a>.  Note the 2-particle
density matrix is reordered to match the 2e integrals of chemists&#8217; notation.
dm2[p,q,r,s] = <span class="math">\(\langle p^\dagger r^\dagger s q\rangle\)</span>;  The
3-particle density matrix takes the similar convention,
dm3[p,q,r,s,t,u] <span class="math">\(= \langle p^\dagger r^\dagger t^\dagger u s q\rangle\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="DMRGCI.trans_rdm1">
<tt class="descname">trans_rdm1</tt><big>(</big><em>statebra</em>, <em>stateket</em>, <em>norb</em>, <em>nelec</em><big>)</big><a class="headerlink" href="#DMRGCI.trans_rdm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the state ID of bra and ket, read the 1-particle density matrix from
the directory indicated by <a class="reference internal" href="#DMRGCI.scratchDirectory" title="DMRGCI.scratchDirectory"><tt class="xref py py-attr docutils literal"><span class="pre">scratchDirectory</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="DMRGCI.trans_rdm12">
<tt class="descname">trans_rdm12</tt><big>(</big><em>statebra</em>, <em>stateket</em>, <em>norb</em>, <em>nelec</em><big>)</big><a class="headerlink" href="#DMRGCI.trans_rdm12" title="Permalink to this definition">¶</a></dt>
<dd><p>Given the state ID of bra and ket, read the 1-particle and 2-particle
density matrices from the directory indicated by <a class="reference internal" href="#DMRGCI.scratchDirectory" title="DMRGCI.scratchDirectory"><tt class="xref py py-attr docutils literal"><span class="pre">scratchDirectory</span></tt></a>.
Note the 2-particle density matrix is reordered to match the 2e integrals of
chemists&#8217; notation, dm2[p,q,r,s] <span class="math">\(= \langle p^\dagger r^\dagger s q\rangle\)</span>.</p>
</dd></dl>

<dl class="method">
<dt id="DMRGCI.kernel">
<tt class="descname">kernel</tt><big>(</big><em>h1e</em>, <em>eri</em>, <em>norb</em>, <em>nelec</em>, <em>fciRestart=None</em>, <em>ecore=0</em><big>)</big><a class="headerlink" href="#DMRGCI.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>The kernel function to call Block program.  &#8220;eri&#8221; is the array of 2-electron
integrals (ij|kl).  8-fold permutation symmetry is required.
The function returns the total energy and the state ID which is
corresponding to the wave-function files in <a class="reference internal" href="#DMRGCI.scratchDirectory" title="DMRGCI.scratchDirectory"><tt class="xref py py-attr docutils literal"><span class="pre">scratchDirectory</span></tt></a>.
If multiple roots were required,  the function returns two lists.  The first
list is the energy of each state.  The second is a list of state ID.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="DMRGSCF">
<tt class="descname">DMRGSCF</tt><big>(</big><em>mf</em>, <em>norb</em>, <em>nelec</em><big>)</big><a class="headerlink" href="#DMRGSCF" title="Permalink to this definition">¶</a></dt>
<dd><p>Shortcut function to setup CASSCF with the DMRG solver.  The DMRG
solver is properly initialized in this function so that the 1-step
algorithm can applied efficiently in DMRG-CASSCF method.</p>
<p>Examples:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s">&#39;N 0 0 0; N 0 0 1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span> <span class="o">=</span> <span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="go">-74.414908818611522</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="state-average-and-state-specific-dmrg-casci-dmrg-casscf">
<h2>State-average and state-specific DMRG-CASCI/DMRG-CASSCF<a class="headerlink" href="#state-average-and-state-specific-dmrg-casci-dmrg-casscf" title="Permalink to this headline">¶</a></h2>
<p>State-average and state-specific calculations were also supported in the
DMRG-CASCI/DMRG-CASSCF through the Block-PySCF interface.  The usage is
the same to that in regular CASCI/CASSCF calculation.
<tt class="xref py py-func docutils literal"><span class="pre">mc.state-average_()</span></tt> function provides the average over the
multiple solutions over a single <tt class="xref py py-attr docutils literal"><span class="pre">fcisolver</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="c"># half-half average over ground state and first excited state</span>
<span class="n">mc</span><span class="o">.</span><span class="n">state_average_</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>In this example, <a class="reference internal" href="#DMRGSCF" title="DMRGSCF"><tt class="xref py py-func docutils literal"><span class="pre">DMRGSCF()</span></tt></a> replaced the <tt class="xref py py-attr docutils literal"><span class="pre">fcisolver</span></tt> with the
<a class="reference internal" href="#DMRGCI" title="DMRGCI"><tt class="xref py py-class docutils literal"><span class="pre">DMRGCI</span></tt></a> object.  Two DMRG states with the same spin and spatial
(point group) symmetry are computed and half-half averaged.  The two states are
saved on the disk indicated by <tt class="xref py py-attr docutils literal"><span class="pre">mc.fcisolver.scratchDirectory</span></tt>.
In many calculations, one would require the state-average for states with
different spin or spatial symmetry.  Multiple FCI/DMRG solvers need to be
created and each solver should handle one particular symmetry.  Function
<tt class="xref py py-func docutils literal"><span class="pre">mcscf.state_average_mix_()</span></tt> offers this functionality to mix different
solvers in a single <tt class="xref py py-attr docutils literal"><span class="pre">fcisolver</span></tt> object:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span><span class="p">,</span> <span class="n">dmrgscf</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s">&quot;N 0 0 0; N 0 0 1&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s">&quot;ccpvdz&quot;</span><span class="p">,</span> <span class="n">symmetry</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">25</span><span class="p">,</span> <span class="o">.</span><span class="mi">25</span><span class="p">]</span>
<span class="n">solver1</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">scratchDirectory</span> <span class="o">=</span> <span class="s">&#39;/scratch/solver1&#39;</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">nroots</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">wfnsym</span> <span class="o">=</span> <span class="s">&#39;a1g&#39;</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">spin</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c"># nelec_alpha - nelec_beta</span>
<span class="n">solver2</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">solver2</span><span class="o">.</span><span class="n">scratchDirectory</span> <span class="o">=</span> <span class="s">&#39;/scratch/solver2&#39;</span>
<span class="n">solver2</span><span class="o">.</span><span class="n">nroots</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">solver2</span><span class="o">.</span><span class="n">wfnsym</span> <span class="o">=</span> <span class="s">&#39;a1u&#39;</span>
<span class="n">mcscf</span><span class="o">.</span><span class="n">state_average_mix_</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="p">[</span><span class="n">solver1</span><span class="p">,</span> <span class="n">solver2</span><span class="p">],</span> <span class="n">weights</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>In this example, one solver for a triplet state of A1g symmetry and another
solver for two singlet states of A1u symmetry are combined into one faked
solver and assigned to <tt class="xref py py-attr docutils literal"><span class="pre">fcisolver</span></tt> by <tt class="xref py py-func docutils literal"><span class="pre">state_average_mix_()</span></tt>.
If the fake solver needs to handle solvers of different spin symmetry, you
need explicitly assign the spin attribute to the solver.  For first solver
<tt class="docutils literal"><span class="pre">solver1</span></tt>, <tt class="docutils literal"><span class="pre">solver1.spin</span> <span class="pre">=</span> <span class="pre">2</span></tt> indciates that the number of
alpha electrons is 2 more than the number of beta electrons.
The <tt class="xref py py-meth docutils literal"><span class="pre">kernel()</span></tt> function of fake solver <tt class="xref py py-attr docutils literal"><span class="pre">mc.fcisolver</span></tt> will return 3
states in a list <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">1]</span></tt>.  The number in the list represents the state
ID in each solver.  The first state (the first 0 in the list) is obtained from
<tt class="docutils literal"><span class="pre">solver1</span></tt>.  Its wave-function and density matrices can be found in
<tt class="docutils literal"><span class="pre">/scratch/solver1</span></tt>.  The second and third elements of <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">1]</span></tt> are the
states obtained from <tt class="docutils literal"><span class="pre">solver2</span></tt>.  The relevant wave functions and density
matrices are all stored in <tt class="docutils literal"><span class="pre">/scratch/solver2</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Block program stores the wave function in <tt class="xref py py-attr docutils literal"><span class="pre">scratchDirectory</span></tt>.
You must assign different <tt class="xref py py-attr docutils literal"><span class="pre">scratchDirectory</span></tt> for different DMRG solvers.
If two Block wave function are put in the same <tt class="xref py py-attr docutils literal"><span class="pre">scratchDirectory</span></tt>, the
solver may crash or produce wrong solution.</p>
</div>
<p>State-specific DMRG-CASSCF is the other common calculation one would take.
Setting up state-specific DMRG-CASSCF object is the same to the regular CASSCF
code.  By calling <tt class="xref py py-meth docutils literal"><span class="pre">mc.state_specific_()</span></tt> function with state ID: 0 for
ground state, 1 for first excited state ..., you can optimize the target state
with DMRG-CASSCF:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Optimize the first excited state</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">state_specific_</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>The <tt class="xref py py-meth docutils literal"><span class="pre">mc.state_specific_()</span></tt> function can be applied with DMRG-CASCI object as
well.  However, a straightforward solution for DMRG-CASCI is to compute multiple
states simultaneously with attribute <tt class="xref py py-attr docutils literal"><span class="pre">nroots</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">nroots</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
</pre></div>
</div>
<p>In PySCF <a class="reference external" href="https://github.com/sunqm/pyscf/blob/master/examples/dmrg">source code</a>,
you can find more examples of state-average and state-specific calculations.</p>
</div>
<div class="section" id="dmrg-nevpt2">
<h2>DMRG-NEVPT2<a class="headerlink" href="#dmrg-nevpt2" title="Permalink to this headline">¶</a></h2>
<p>For Block 1.1.1 version or older, the standard DMRG-NEVPT2 calculation can be
carried out on top of the DMRG-CASCI or DMRG-CASSCF calculation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">dmrgscf</span><span class="p">,</span> <span class="n">mrpt</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s">&quot;N 0 0 0; N 0 0 1&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s">&quot;ccpvdz&quot;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mrpt</span><span class="o">.</span><span class="n">NEVPT</span><span class="p">(</span><span class="n">mc</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mrpt</span><span class="o">.</span><span class="n">NEVPT</span><span class="p">(</span><span class="n">mc</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>The standard DMRG-NEVPT2 method requires the 4-particle density matrix.
Computing and storing the 4-particle density matrix is extremely demanding.  It
limits the system size to at most 26 orbitals.  Starting from Block 1.1 version,
we implemented an effective approximation based on compressed MPS-perturber
technique which can significantly reduce the computation cost.  The MPS-perturber
NEVPT2 implementation requires the <a class="reference external" href="http://mpi4py.scipy.org">MPI4Py</a> library
and the <strong>serial version</strong> of Block program.  You need set in the config file
<tt class="file docutils literal"><span class="pre">/path/to/pyscf/future/dmrgscf/settings.py</span></tt> the variable
<tt class="docutils literal"><span class="pre">BLOCKEXE_COMPRESS_NEVPT</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">BLOCKEXE_COMPRESS_NEVPT</span> <span class="o">=</span> <span class="s">&quot;/path/to/serially/compiled/Block/block.spin_adapted-serial&quot;</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The wavefunction structure from different Block versions are incompatible.  If
BLOCKEXE for zeroth order wavefunction is set to Block-1.1, BLOCKEXE_COMPRESS_NEVPT
for PT should also be Block-1.1.  Similarly, Block-1.5 (stackblock) PT code
only compatible with the zeroth order wavefunction of Block-1.5 (stackblock).</p>
</div>
<p>Now you can use <tt class="xref py py-func docutils literal"><span class="pre">compress_approx()</span></tt> function to initialize a compressed
pertuber NEVPT2 method.  In the <tt class="xref py py-func docutils literal"><span class="pre">compress_approx()</span></tt> function, we precomputed
the most demanding intermediates and stored them on disk:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">dmrgscf</span><span class="p">,</span> <span class="n">mrpt</span>
<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s">&quot;N 0 0 0; N 0 0 1&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s">&quot;ccpvdz&quot;</span><span class="p">)</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">dmrgci</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mrpt</span><span class="o">.</span><span class="n">NEVPT</span><span class="p">(</span><span class="n">mc</span><span class="p">)</span><span class="o">.</span><span class="n">compress_approx</span><span class="p">()</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The compressed NEVPT2 algorithm is also very demanding, especially on the memory
usage.  It can support up to about 35 orbitals in Block-1.5.  Please refer to
the <a class="reference internal" href="benchmark.html#benchmark"><em>Benchmark</em></a> for approximate costs.</p>
</div>
<p>If the excitation energy is of interest, we can use DMRG-NEVPT2 to compute the
energy of excited state based on the multiple-root CASCI calculations:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">nroots</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="n">mrpt</span><span class="o">.</span><span class="n">NEVPT</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">compress_approx</span><span class="p">(</span><span class="n">maxM</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mrpt</span><span class="o">.</span><span class="n">NEVPT</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">compress_approx</span><span class="p">(</span><span class="n">maxM</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
<p>In the above example, two NEVPT2 calculations are called separately for
two states which are indicated by the argument <tt class="docutils literal"><span class="pre">root=*</span></tt>.  If the DMRG-NEVPT2
calculations are called based on the state-average DMRG-CASSCF calculation, you
should be very careful with <tt class="xref py py-attr docutils literal"><span class="pre">scratchDirectory</span></tt> for the DMRG wave function
that NEVPT2 perturbation is applied on.  In the multiple-solver state-average
DMRG-CASSCF calculation,  you need assign the right <tt class="xref py py-attr docutils literal"><span class="pre">fcisolver</span></tt> and state
ID to the <tt class="docutils literal"><span class="pre">mc</span></tt> object before passing it to <tt class="xref py py-func docutils literal"><span class="pre">mrpt.NEVPT()</span></tt> method.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">weights</span> <span class="o">=</span> <span class="p">[</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="o">.</span><span class="mi">25</span><span class="p">,</span> <span class="o">.</span><span class="mi">25</span><span class="p">]</span>
<span class="n">solver1</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">scratchDirectory</span> <span class="o">=</span> <span class="s">&#39;/scratch/solver1&#39;</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">nroots</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">wfnsym</span> <span class="o">=</span> <span class="s">&#39;a1g&#39;</span>
<span class="n">solver1</span><span class="o">.</span><span class="n">spin</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c"># nelec_alpha - nelec_beta</span>
<span class="n">solver2</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGCI</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>
<span class="n">solver2</span><span class="o">.</span><span class="n">scratchDirectory</span> <span class="o">=</span> <span class="s">&#39;/scratch/solver2&#39;</span>
<span class="n">solver2</span><span class="o">.</span><span class="n">nroots</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">solver2</span><span class="o">.</span><span class="n">wfnsym</span> <span class="o">=</span> <span class="s">&#39;a1u&#39;</span>
<span class="n">mcscf</span><span class="o">.</span><span class="n">state_average_mix_</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="p">[</span><span class="n">solver1</span><span class="p">,</span> <span class="n">solver2</span><span class="p">],</span> <span class="n">weights</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">solver1</span>
<span class="n">mrpt</span><span class="o">.</span><span class="n">NEVPT</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">compress_approx</span><span class="p">(</span><span class="n">maxM</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>

<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">solver2</span>
<span class="n">mrpt</span><span class="o">.</span><span class="n">NEVPT</span><span class="p">(</span><span class="n">mc</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">compress_approx</span><span class="p">(</span><span class="n">maxM</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="case-study">
<h2>Case study<a class="headerlink" href="#case-study" title="Permalink to this headline">¶</a></h2>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#!/usr/bin/env python</span>
<span class="c">#</span>
<span class="c"># Contributors:</span>
<span class="c">#       Zhendong Li &lt;zhendongli2008@gmail.com&gt;</span>
<span class="c">#       Qiming Sun &lt;osirpt.sun@gmail.com&gt;</span>
<span class="c">#</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>
<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">mcscf</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">tools</span>

<span class="n">mol</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">Mole</span><span class="p">()</span>
<span class="n">mol</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">mol</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="s">&#39;hs.out&#39;</span>
<span class="n">mol</span><span class="o">.</span><span class="n">atom</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;</span>
<span class="s">  Mo  7.34411020207581      1.17495097908005      6.72284263905920</span>
<span class="s">  Fe  7.84036274632279      2.40948832380662      3.90857987198295</span>
<span class="s">  S   8.11413397508734      3.34683967317511      5.92473122721237</span>
<span class="s">  Cl  9.42237962692288      2.83901882053830      2.40523971787167</span>
<span class="s">  S   7.63129189448338      0.24683725427736      4.48256715460659</span>
<span class="s">  Cl  5.78420653505383      3.15381896731458      3.13969003482939</span>
<span class="s">  N   7.05276738605521      2.42445066370842      8.66076404425459</span>
<span class="s">  N   6.64167403727998     -1.00707407196440      7.11600799320614</span>
<span class="s">  N   5.24002742536262      1.70306900993116      5.97156233521481</span>
<span class="s">  H   6.27407522563538      2.37009344884271      9.32021452836747</span>
<span class="s">  H   7.93656914286549      2.22405698642280      9.14675757456406</span>
<span class="s">  H   7.12313637861828      3.37423478174186      8.26848891472229</span>
<span class="s">  H   4.53157107313027      2.02429015953190      6.63557341863725</span>
<span class="s">  H   5.36325579034589      2.43796505637839      5.24458486826946</span>
<span class="s">  H   4.86812692298093      0.90155604764634      5.45231738540969</span>
<span class="s">  H   5.82209673287966     -1.30027608533573      7.65147593202357</span>
<span class="s">  H   6.56861368828978     -1.33871396574670      6.14286445056596</span>
<span class="s">  H   7.48831993436433     -1.42577562013418      7.51985443522153</span>
<span class="s">  S   9.40594188780477      0.42545761808747      7.87277304102829</span>
<span class="s">  H   8.82966334944139     -0.10099345030206      8.99111747895267</span>
<span class="s">&#39;&#39;&#39;</span>
<span class="n">mol</span><span class="o">.</span><span class="n">basis</span> <span class="o">=</span> <span class="s">&#39;tzp-dkh&#39;</span>
<span class="n">mol</span><span class="o">.</span><span class="n">charge</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">mol</span><span class="o">.</span><span class="n">spin</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">()</span>

<span class="c">#</span>
<span class="c"># X2C correction for relativistic effects</span>
<span class="c">#</span>
<span class="c"># first pass, to generate initial guess</span>
<span class="c">#</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">sfx2c</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">UHF</span><span class="p">(</span><span class="n">mol</span><span class="p">))</span>
<span class="n">mf</span><span class="o">.</span><span class="n">chkfile</span> <span class="o">=</span> <span class="s">&#39;hs.chk&#39;</span>
<span class="n">mf</span><span class="o">.</span><span class="n">level_shift</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="n">mf</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-2</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>
<span class="c">#</span>
<span class="c"># second pass to converge SCF calculation</span>
<span class="c">#</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">newton</span><span class="p">(</span><span class="n">mf</span><span class="p">)</span>
<span class="n">mf</span><span class="o">.</span><span class="n">conv_tol</span> <span class="o">=</span> <span class="mf">1e-12</span>
<span class="n">mf</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>




<span class="c">##################################################</span>
<span class="c">#</span>
<span class="c"># Analyze SCF results and make MCSCF initial guess</span>
<span class="c">#</span>
<span class="c">##################################################</span>

<span class="c"># This parameter to control the call to matplotlib</span>
<span class="n">ifplot</span> <span class="o">=</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">sqrtm</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">e</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="o">*</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">lowdin</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">e</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="o">/</span><span class="n">numpy</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>

<span class="c">##################################################</span>
<span class="c">#</span>
<span class="c"># 1. Read UHF-alpha/beta orbitals from chkfile</span>
<span class="c">#</span>
<span class="c">##################################################</span>
<span class="n">fname</span> <span class="o">=</span> <span class="s">&#39;hs.chk&#39;</span>
<span class="n">chkfile</span> <span class="o">=</span> <span class="n">fname</span>
<span class="n">mol</span><span class="p">,</span> <span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">chkfile</span><span class="o">.</span><span class="n">load_scf</span><span class="p">(</span><span class="n">chkfile</span><span class="p">)</span>
<span class="n">mo_coeff</span> <span class="o">=</span> <span class="n">mf</span><span class="p">[</span><span class="s">&quot;mo_coeff&quot;</span><span class="p">]</span>
<span class="n">ma</span> <span class="o">=</span> <span class="n">mo_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">mb</span> <span class="o">=</span> <span class="n">mo_coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">nb</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">nalpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span><span class="o">+</span><span class="n">mol</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="n">nbeta</span>  <span class="o">=</span> <span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span><span class="o">-</span><span class="n">mol</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Nalpha = </span><span class="si">%d</span><span class="s">, Nbeta </span><span class="si">%d</span><span class="s">, Sz = </span><span class="si">%d</span><span class="s">, Norb = </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nalpha</span><span class="p">,</span> <span class="n">nbeta</span><span class="p">,</span> <span class="n">mol</span><span class="o">.</span><span class="n">spin</span><span class="p">,</span> <span class="n">nb</span><span class="p">))</span>

<span class="c">#=============================</span>
<span class="c"># DUMP from chkfile to molden</span>
<span class="c">#=============================</span>
<span class="c">#</span>
<span class="c"># One can view the orbitals in many visualization tool like Jmol, IBOviewer</span>
<span class="c">#</span>
<span class="n">moldenfile</span> <span class="o">=</span> <span class="n">fname</span><span class="o">+</span><span class="s">&#39;0.molden&#39;</span>
<span class="n">tools</span><span class="o">.</span><span class="n">molden</span><span class="o">.</span><span class="n">from_chkfile</span><span class="p">(</span><span class="n">moldenfile</span><span class="p">,</span> <span class="n">chkfile</span><span class="p">)</span>
<span class="k">if</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c"># Jmol script to generate orbital images.  Run this jmol script in command line</span>
    <span class="c">#       jmol hs.spt</span>
    <span class="c"># It writes out images for 10 HOMO and 10 LUMO orbitals.</span>
    <span class="n">tools</span><span class="o">.</span><span class="n">molden</span><span class="o">.</span><span class="n">from_mo</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">fname</span><span class="o">+</span><span class="s">&#39;_alpha.molden&#39;</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>
    <span class="n">tools</span><span class="o">.</span><span class="n">molden</span><span class="o">.</span><span class="n">from_mo</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">fname</span><span class="o">+</span><span class="s">&#39;_beta.molden&#39;</span><span class="p">,</span> <span class="n">mb</span><span class="p">)</span>
    <span class="n">jmol_script</span> <span class="o">=</span> <span class="s">&#39;hs.spt&#39;</span>
    <span class="n">fspt</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">jmol_script</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">fspt</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;&#39;&#39;</span>
<span class="s">initialize;</span>
<span class="s">set background [xffffff];</span>
<span class="s">set frank off</span>
<span class="s">set autoBond true;</span>
<span class="s">set bondRadiusMilliAngstroms 66;</span>
<span class="s">set bondTolerance 0.5;</span>
<span class="s">set forceAutoBond false;</span>
<span class="s">#cd /home/abc/pyscf/examples/dmrg</span>
<span class="s">&#39;&#39;&#39;</span><span class="p">)</span>
    <span class="n">fspt</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;load </span><span class="si">%s</span><span class="s">_beta.molden;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">fname</span><span class="p">)</span>
    <span class="n">fspt</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;rotate -30 y;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="n">fspt</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;rotate 20 x;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nalpha</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="n">nalpha</span><span class="o">+</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">fspt</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;isoSurface MO </span><span class="si">%d</span><span class="s"> fill noMesh noDots;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">fspt</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;#color isoSurface translucent 0.6 [x00ff00];</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">fspt</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;write JPG 90 &quot;</span><span class="si">%s</span><span class="s">-alpha-</span><span class="si">%d</span><span class="s">.jpg&quot;;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">jmol_script</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>

    <span class="n">fspt</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;load </span><span class="si">%s</span><span class="s">_alpha.molden;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">fname</span><span class="p">)</span>
    <span class="n">fspt</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;rotate -30 y;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="n">fspt</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;rotate 20 x;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbeta</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span><span class="n">nbeta</span><span class="o">+</span><span class="mi">10</span><span class="p">):</span>
        <span class="n">fspt</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;isoSurface MO </span><span class="si">%d</span><span class="s"> fill noMesh noDots;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">fspt</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;#color isoSurface translucent 0.6 [x0000ff];</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="n">fspt</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;write JPG 90 &quot;</span><span class="si">%s</span><span class="s">-beta-</span><span class="si">%d</span><span class="s">.jpg&quot;;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">jmol_script</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">fspt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="c">##################################################</span>
<span class="c">#</span>
<span class="c"># 2. Sanity check, using eg orthogonality</span>
<span class="c">#</span>
<span class="c">##################################################</span>
<span class="n">ova</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor_symmetric</span><span class="p">(</span><span class="s">&quot;cint1e_ovlp_sph&quot;</span><span class="p">)</span>
<span class="n">diff</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,(</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">ova</span><span class="p">,</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>
<span class="n">diff</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,(</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">ova</span><span class="p">,</span><span class="n">mo_coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>

<span class="c">#=============================</span>
<span class="c"># Natural orbitals</span>
<span class="c"># Lowdin basis X=S{-1/2}</span>
<span class="c"># psi = chi * C</span>
<span class="c">#     = chi&#39; * C&#39;</span>
<span class="c">#     = chi*X*(X{-1}C&#39;)</span>
<span class="c">#=============================</span>
<span class="n">pTa</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ma</span><span class="p">[:,:</span><span class="n">nalpha</span><span class="p">],</span><span class="n">ma</span><span class="p">[:,:</span><span class="n">nalpha</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="n">pTb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mb</span><span class="p">[:,:</span><span class="n">nbeta</span><span class="p">],</span><span class="n">mb</span><span class="p">[:,:</span><span class="n">nbeta</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="n">pT</span> <span class="o">=</span> <span class="n">pTa</span><span class="o">+</span><span class="n">pTb</span>
<span class="n">pT</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">pT</span>
<span class="c"># Lowdin basis</span>
<span class="n">s12</span> <span class="o">=</span> <span class="n">sqrtm</span><span class="p">(</span><span class="n">ova</span><span class="p">)</span>
<span class="n">s12inv</span> <span class="o">=</span> <span class="n">lowdin</span><span class="p">(</span><span class="n">ova</span><span class="p">)</span>
<span class="n">pT</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,(</span><span class="n">s12</span><span class="p">,</span><span class="n">pT</span><span class="p">,</span><span class="n">s12</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;idemponency of DM: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pT</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pT</span><span class="p">)</span><span class="o">-</span><span class="n">pT</span><span class="p">))</span>
<span class="n">enorb</span> <span class="o">=</span> <span class="n">mf</span><span class="p">[</span><span class="s">&quot;mo_energy&quot;</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">CMO_enorb:&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">enorb</span><span class="p">)</span>
<span class="k">if</span> <span class="n">ifplot</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">),</span><span class="n">enorb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s">&#39;ro&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">),</span><span class="n">enorb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">&#39;bo&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c">#</span>
<span class="c"># Non-orthogonal cases: FC=SCE</span>
<span class="c"># Fao = SC*e*C{-1} = S*C*e*Ct*S</span>
<span class="c"># OAO basis:</span>
<span class="c"># F = Xt*Fao*X = S1/2*C*e*Ct*S1/2</span>
<span class="c">#</span>
<span class="n">fa</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,(</span><span class="n">ma</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">enorb</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">ma</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="n">fb</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,(</span><span class="n">mb</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">enorb</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">mb</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="n">fav</span> <span class="o">=</span> <span class="p">(</span><span class="n">fa</span><span class="o">+</span><span class="n">fb</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
<span class="n">fock_sf</span> <span class="o">=</span> <span class="n">fOAO</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,(</span><span class="n">s12</span><span class="p">,</span><span class="n">fav</span><span class="p">,</span><span class="n">s12</span><span class="p">))</span>
<span class="c">#</span>
<span class="c"># Small level shift on density matrix to break occupation degeneracy in natual</span>
<span class="c"># orbitals</span>
<span class="c">#</span>
<span class="n">shift</span> <span class="o">=</span> <span class="mf">1e-7</span>
<span class="n">pTshift</span> <span class="o">=</span> <span class="n">pT</span> <span class="o">+</span> <span class="n">shift</span><span class="o">*</span><span class="n">fOAO</span>
<span class="c">#</span>
<span class="c"># &#39;natural&#39; occupations and orbitals</span>
<span class="c">#</span>
<span class="n">eig</span><span class="p">,</span><span class="n">coeff</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">pTshift</span><span class="p">)</span>
<span class="n">eig</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">eig</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Natual occupancy </span><span class="si">%s</span><span class="s"> &#39;</span> <span class="o">%</span> <span class="n">eig</span><span class="p">)</span>
<span class="n">eig</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">eig</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1.e-14</span><span class="p">]</span><span class="o">=</span><span class="mf">0.0</span>
<span class="k">if</span> <span class="n">ifplot</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">),</span><span class="n">eig</span><span class="p">,</span><span class="s">&#39;ro&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<span class="c">#</span>
<span class="c"># Rotate back to AO representation and check orthogonality</span>
<span class="c">#</span>
<span class="n">coeff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">s12inv</span><span class="p">,</span><span class="n">coeff</span><span class="p">)</span>
<span class="n">ova</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor_symmetric</span><span class="p">(</span><span class="s">&quot;cint1e_ovlp_sph&quot;</span><span class="p">)</span>
<span class="n">diff</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,(</span><span class="n">coeff</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">ova</span><span class="p">,</span><span class="n">coeff</span><span class="p">))</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;CtSC-I&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>


<span class="c">##################################################</span>
<span class="c">#</span>
<span class="c"># 3. Search for active space</span>
<span class="c">#</span>
<span class="c">##################################################</span>

<span class="c">#</span>
<span class="c"># 3.1 Transform the entire MO space into core, active, and external space</span>
<span class="c"># based on natural occupancy</span>
<span class="c">#</span>
<span class="c"># Expectation value of natural orbitals &lt;i|F|i&gt;</span>
<span class="n">fexpt</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,(</span><span class="n">coeff</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">ova</span><span class="p">,</span><span class="n">fav</span><span class="p">,</span><span class="n">ova</span><span class="p">,</span><span class="n">coeff</span><span class="p">))</span>
<span class="n">enorb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">fexpt</span><span class="p">)</span>
<span class="c"># Sort by occupancy</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">eig</span><span class="p">)</span>
<span class="n">enorb</span> <span class="o">=</span> <span class="n">enorb</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
<span class="n">nocc</span>  <span class="o">=</span> <span class="n">eig</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
<span class="n">coeff</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[:,</span><span class="n">index</span><span class="p">]</span>
<span class="c">#</span>
<span class="c"># Reordering and define active space according to thresh</span>
<span class="c">#</span>
<span class="n">thresh</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">active</span> <span class="o">=</span> <span class="p">(</span><span class="n">thresh</span> <span class="o">&lt;=</span> <span class="n">nocc</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nocc</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="o">-</span><span class="n">thresh</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">Natural orbitals:&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Offdiag(F) = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">fexpt</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">enorb</span><span class="p">)))</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;orb:&#39;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">active</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">nocc</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">enorb</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
<span class="n">actIndices</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">active</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;active orbital indices </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">actIndices</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Num active orbitals </span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">actIndices</span><span class="p">))</span>
<span class="n">cOrbs</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[:,:</span><span class="n">actIndices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="n">aOrbs</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[:,</span><span class="n">actIndices</span><span class="p">]</span>
<span class="n">vOrbs</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[:,</span><span class="n">actIndices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">nb</span> <span class="o">=</span> <span class="n">cOrbs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">nc</span> <span class="o">=</span> <span class="n">cOrbs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">na</span> <span class="o">=</span> <span class="n">aOrbs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="n">nv</span> <span class="o">=</span> <span class="n">vOrbs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;core orbs:&#39;</span><span class="p">,</span><span class="n">cOrbs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;act  orbs:&#39;</span><span class="p">,</span><span class="n">aOrbs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;vir  orbs:&#39;</span><span class="p">,</span><span class="n">vOrbs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">nc</span><span class="o">+</span><span class="n">na</span><span class="o">+</span><span class="n">nv</span> <span class="o">==</span> <span class="n">nb</span>

<span class="c">#</span>
<span class="c"># 3.2 Localizing core, active, external space separately, based on certain</span>
<span class="c"># local orbitals.</span>
<span class="c">#</span>
<span class="c"># We now dump out UHF natual orbitals and localized orbitals to help identify</span>
<span class="c"># active space.</span>
<span class="c">#</span>
<span class="c"># dump UHF natrual orbital</span>
<span class="c">#</span>
<span class="n">tools</span><span class="o">.</span><span class="n">molden</span><span class="o">.</span><span class="n">from_mo</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">fname</span><span class="o">+</span><span class="s">&#39;_uno.molden&#39;</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>

<span class="c">#=============================</span>
<span class="c"># localized orbitals</span>
<span class="c">#=============================</span>
<span class="n">iflocal</span>  <span class="o">=</span> <span class="bp">False</span>
<span class="k">if</span> <span class="n">iflocal</span><span class="p">:</span>
    <span class="c"># We implemented different localization later</span>
    <span class="kn">from</span> <span class="nn">pyscf.tools</span> <span class="kn">import</span> <span class="n">localizer</span>
    <span class="n">loc</span> <span class="o">=</span> <span class="n">localizer</span><span class="o">.</span><span class="n">localizer</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span><span class="n">ma</span><span class="p">[:,:</span><span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span><span class="s">&#39;boys&#39;</span><span class="p">)</span>
    <span class="n">loc</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">new_coeff</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>
    <span class="n">loc</span> <span class="o">=</span> <span class="n">localizer</span><span class="o">.</span><span class="n">localizer</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span><span class="n">ma</span><span class="p">[:,</span><span class="n">mol</span><span class="o">.</span><span class="n">nelectron</span><span class="o">/</span><span class="mi">2</span><span class="p">:],</span><span class="s">&#39;boys&#39;</span><span class="p">)</span>
    <span class="n">new_coeff2</span> <span class="o">=</span> <span class="n">loc</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>
    <span class="n">lmo</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">new_coeff</span><span class="p">,</span><span class="n">new_coeff2</span><span class="p">])</span>
    <span class="n">tools</span><span class="o">.</span><span class="n">molden</span><span class="o">.</span><span class="n">from_mo</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">fname</span><span class="o">+</span><span class="s">&#39;lmo.molden&#39;</span><span class="p">,</span> <span class="n">lmo</span><span class="p">)</span>

<span class="c">#</span>
<span class="c"># Test orthogonality because occasionally localization procedure may break the</span>
<span class="c"># orbital orthogonality (when AO functions are close to linear dependent).</span>
<span class="c">#</span>
<span class="n">cOrbsOAO</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">s12</span><span class="p">,</span><span class="n">cOrbs</span><span class="p">)</span>
<span class="n">aOrbsOAO</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">s12</span><span class="p">,</span><span class="n">aOrbs</span><span class="p">)</span>
<span class="n">vOrbsOAO</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">s12</span><span class="p">,</span><span class="n">vOrbs</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Ortho-cOAO&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">cOrbsOAO</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">cOrbsOAO</span><span class="p">)</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">nc</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Ortho-aOAO&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">aOrbsOAO</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">aOrbsOAO</span><span class="p">)</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">na</span><span class="p">)))</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Ortho-vOAO&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vOrbsOAO</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">vOrbsOAO</span><span class="p">)</span><span class="o">-</span><span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">nv</span><span class="p">)))</span>

<span class="c">#==========================================</span>
<span class="c"># Now try to get localized molecular orbitals (SCDM)</span>
<span class="c">#==========================================</span>
<span class="k">def</span> <span class="nf">scdm</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span> <span class="n">aux</span><span class="p">):</span>
<span class="c">#</span>
<span class="c"># Argument coeff is a set of orthogonal orbitals |O&gt; (eg occupied HF</span>
<span class="c"># orbitals); aux is a set of localized orbitals.  One can define a subset |B&gt;</span>
<span class="c"># of aux, which has the closest overlap to the coeff space.</span>
<span class="c"># The (orthogonalized) resultant local orbitals |B&gt; can be considered as the</span>
<span class="c"># localized coeff |O&gt;</span>
<span class="c">#</span>
<span class="c">#       |B&gt; = |O&gt;&lt;O|aux&gt;, in which det(&lt;O|aux&gt;) is maximized;</span>
<span class="c">#       return lowdin(|B&gt;)</span>
<span class="c">#</span>
    <span class="n">no</span> <span class="o">=</span> <span class="n">coeff</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ova</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,(</span><span class="n">coeff</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span> <span class="n">aux</span><span class="p">))</span>
    <span class="c"># ova = no*nb</span>
    <span class="n">q</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">piv</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">ova</span><span class="p">,</span> <span class="n">pivoting</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c"># piv[:no] defines the subset of aux which has the largest overlap to coeff space</span>
    <span class="n">bc</span> <span class="o">=</span> <span class="n">ova</span><span class="p">[:,</span><span class="n">piv</span><span class="p">[:</span><span class="n">no</span><span class="p">]]</span>

    <span class="n">ova</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">bc</span><span class="p">)</span>
    <span class="n">s12inv</span> <span class="o">=</span> <span class="n">lowdin</span><span class="p">(</span><span class="n">ova</span><span class="p">)</span>
    <span class="n">cnew</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,(</span><span class="n">coeff</span><span class="p">,</span><span class="n">bc</span><span class="p">,</span><span class="n">s12inv</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">cnew</span>
<span class="c">#</span>
<span class="c"># Various choices for the localized orbitals</span>
<span class="c"># * the non-orthogonal AOs</span>
<span class="c">#       aux=numpy.identity(nb)</span>
<span class="c"># * Lowdin orthogonalized AOs</span>
<span class="n">aux</span> <span class="o">=</span> <span class="n">s12inv</span>
<span class="c"># * Meta-lowdin orthogonalized AOs</span>
<span class="c">#       from pyscf import lo</span>
<span class="c">#       aux = lo.orth.orth_ao(mol,method=&#39;meta_lowdin&#39;,pre_orth_ao=lo.orth.pre_orth_ao(mol))</span>
<span class="c"># * ...</span>
<span class="c">#</span>
<span class="n">ova</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">intor_symmetric</span><span class="p">(</span><span class="s">&quot;cint1e_ovlp_sph&quot;</span><span class="p">)</span>
<span class="n">clmo</span> <span class="o">=</span> <span class="n">scdm</span><span class="p">(</span><span class="n">cOrbs</span><span class="p">,</span> <span class="n">ova</span><span class="p">,</span> <span class="n">aux</span><span class="p">)</span>  <span class="c"># local &quot;AOs&quot; in core space</span>
<span class="n">almo</span> <span class="o">=</span> <span class="n">scdm</span><span class="p">(</span><span class="n">aOrbs</span><span class="p">,</span> <span class="n">ova</span><span class="p">,</span> <span class="n">aux</span><span class="p">)</span>  <span class="c"># local &quot;AOs&quot; in active space</span>
<span class="n">vlmo</span> <span class="o">=</span> <span class="n">scdm</span><span class="p">(</span><span class="n">vOrbs</span><span class="p">,</span> <span class="n">ova</span><span class="p">,</span> <span class="n">aux</span><span class="p">)</span>  <span class="c"># local &quot;AOs&quot; in external space</span>


<span class="c">#</span>
<span class="c"># 3.3 Sorting each space (core, active, external) based on &quot;orbital energy&quot; to</span>
<span class="c"># prevent high-lying orbitals standing in valence space.</span>
<span class="c">#</span>
<span class="c"># Get &lt;i|F|i&gt;</span>
<span class="k">def</span> <span class="nf">psort</span><span class="p">(</span><span class="n">ova</span><span class="p">,</span> <span class="n">fav</span><span class="p">,</span> <span class="n">coeff</span><span class="p">):</span>
    <span class="c"># pT is density matrix, fav is Fock matrix</span>
    <span class="c"># OCC-SORT</span>
    <span class="n">pTnew</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="nb">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,(</span><span class="n">coeff</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">s12</span><span class="p">,</span><span class="n">pT</span><span class="p">,</span><span class="n">s12</span><span class="p">,</span><span class="n">coeff</span><span class="p">))</span>
    <span class="n">nocc</span>  <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pTnew</span><span class="p">)</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">nocc</span><span class="p">)</span>
    <span class="n">ncoeff</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[:,</span><span class="n">index</span><span class="p">]</span>
    <span class="n">nocc</span>   <span class="o">=</span> <span class="n">nocc</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="n">enorb</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="nb">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,(</span><span class="n">ncoeff</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">ova</span><span class="p">,</span><span class="n">fav</span><span class="p">,</span><span class="n">ova</span><span class="p">,</span><span class="n">ncoeff</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">ncoeff</span><span class="p">,</span> <span class="n">nocc</span><span class="p">,</span> <span class="n">enorb</span>

<span class="c"># E-SORT</span>
<span class="n">mo_c</span><span class="p">,</span> <span class="n">n_c</span><span class="p">,</span> <span class="n">e_c</span> <span class="o">=</span> <span class="n">psort</span><span class="p">(</span><span class="n">ova</span><span class="p">,</span> <span class="n">fav</span><span class="p">,</span> <span class="n">clmo</span><span class="p">)</span>
<span class="n">mo_o</span><span class="p">,</span> <span class="n">n_o</span><span class="p">,</span> <span class="n">e_o</span> <span class="o">=</span> <span class="n">psort</span><span class="p">(</span><span class="n">ova</span><span class="p">,</span> <span class="n">fav</span><span class="p">,</span> <span class="n">almo</span><span class="p">)</span>
<span class="n">mo_v</span><span class="p">,</span> <span class="n">n_v</span><span class="p">,</span> <span class="n">e_v</span> <span class="o">=</span> <span class="n">psort</span><span class="p">(</span><span class="n">ova</span><span class="p">,</span> <span class="n">fav</span><span class="p">,</span> <span class="n">vlmo</span><span class="p">)</span>
<span class="c">#</span>
<span class="c"># coeff is the local molecular orbitals</span>
<span class="c">#</span>
<span class="n">coeff</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">mo_c</span><span class="p">,</span> <span class="n">mo_o</span><span class="p">,</span> <span class="n">mo_v</span><span class="p">))</span>

<span class="c">#</span>
<span class="c"># Test orthogonality for the localize MOs as before</span>
<span class="c">#</span>
<span class="n">diff</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,(</span><span class="n">coeff</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">ova</span><span class="p">,</span><span class="n">coeff</span><span class="p">))</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;diff=&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>
<span class="n">tools</span><span class="o">.</span><span class="n">molden</span><span class="o">.</span><span class="n">from_mo</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">fname</span><span class="o">+</span><span class="s">&#39;_scdm.molden&#39;</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>

<span class="c">#</span>
<span class="c"># Population analysis to confirm that our LMO (coeff) make sense</span>
<span class="c">#</span>
<span class="c">#==========================================</span>
<span class="c"># lowdin-pop of the obtained LMOs in OAOs</span>
<span class="c">#==========================================</span>
<span class="n">lcoeff</span> <span class="o">=</span> <span class="n">s12</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
<span class="c"># Orthogonality test</span>
<span class="n">diff</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">,(</span><span class="n">lcoeff</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">lcoeff</span><span class="p">))</span> <span class="o">-</span> <span class="n">numpy</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="n">nb</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;diff=&#39;</span><span class="p">,</span><span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">Lowdin population for LMOs:&#39;</span><span class="p">)</span>

<span class="n">pthresh</span> <span class="o">=</span> <span class="mf">0.02</span>
<span class="n">labels</span> <span class="o">=</span> <span class="n">mol</span><span class="o">.</span><span class="n">spheric_labels</span><span class="p">()</span>
<span class="n">ifACTONLY</span> <span class="o">=</span> <span class="bp">False</span> <span class="c">#True</span>
<span class="n">nelec</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">nact</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="k">for</span> <span class="n">iorb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="n">lcoeff</span><span class="p">[:,</span><span class="n">iorb</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">vec</span><span class="o">&gt;</span><span class="n">pthresh</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">ifACTONLY</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">iorb</span> <span class="o">&lt;</span> <span class="n">nc</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39; iorb_C=&#39;</span><span class="p">,</span><span class="n">iorb</span><span class="p">,</span><span class="s">&#39; occ=&#39;</span><span class="p">,</span><span class="n">n_c</span><span class="p">[</span><span class="n">iorb</span><span class="p">],</span><span class="s">&#39; fii=&#39;</span><span class="p">,</span><span class="n">e_c</span><span class="p">[</span><span class="n">iorb</span><span class="p">])</span>
            <span class="n">nelec</span> <span class="o">+=</span> <span class="n">n_c</span><span class="p">[</span><span class="n">iorb</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">iorb</span> <span class="o">&gt;=</span> <span class="n">nc</span> <span class="ow">and</span> <span class="n">iorb</span> <span class="o">&lt;</span> <span class="n">nc</span><span class="o">+</span><span class="n">na</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39; iorb_A=&#39;</span><span class="p">,</span><span class="n">iorb</span><span class="p">,</span><span class="s">&#39; occ=&#39;</span><span class="p">,</span><span class="n">n_o</span><span class="p">[</span><span class="n">iorb</span><span class="o">-</span><span class="n">nc</span><span class="p">],</span><span class="s">&#39; faa=&#39;</span><span class="p">,</span><span class="n">e_o</span><span class="p">[</span><span class="n">iorb</span><span class="o">-</span><span class="n">nc</span><span class="p">])</span>
            <span class="n">nelec</span> <span class="o">+=</span> <span class="n">n_o</span><span class="p">[</span><span class="n">iorb</span><span class="o">-</span><span class="n">nc</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39; iorb_V=&#39;</span><span class="p">,</span><span class="n">iorb</span><span class="p">,</span><span class="s">&#39; occ=&#39;</span><span class="p">,</span><span class="n">n_v</span><span class="p">[</span><span class="n">iorb</span><span class="o">-</span><span class="n">nc</span><span class="o">-</span><span class="n">na</span><span class="p">],</span><span class="s">&#39; fvv=&#39;</span><span class="p">,</span><span class="n">e_v</span><span class="p">[</span><span class="n">iorb</span><span class="o">-</span><span class="n">nc</span><span class="o">-</span><span class="n">na</span><span class="p">])</span>
            <span class="n">nelec</span> <span class="o">+=</span> <span class="n">n_v</span><span class="p">[</span><span class="n">iorb</span><span class="o">-</span><span class="n">nc</span><span class="o">-</span><span class="n">na</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">iao</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39;    iao=&#39;</span><span class="p">,</span><span class="n">labels</span><span class="p">[</span><span class="n">iao</span><span class="p">],</span><span class="s">&#39; pop=&#39;</span><span class="p">,</span><span class="n">vec</span><span class="p">[</span><span class="n">iao</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">iorb</span> <span class="o">&gt;=</span> <span class="n">nc</span> <span class="ow">and</span> <span class="n">iorb</span> <span class="o">&lt;</span> <span class="n">nc</span><span class="o">+</span><span class="n">na</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&#39; iorb_A=&#39;</span><span class="p">,</span><span class="n">iorb</span><span class="p">,</span><span class="s">&#39; faa=&#39;</span><span class="p">,</span><span class="n">e_o</span><span class="p">[</span><span class="n">iorb</span><span class="o">-</span><span class="n">nc</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">iao</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&#39;    iao=&#39;</span><span class="p">,</span><span class="n">labels</span><span class="p">[</span><span class="n">iao</span><span class="p">],</span><span class="s">&#39; pop=&#39;</span><span class="p">,</span><span class="n">vec</span><span class="p">[</span><span class="n">iao</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;nelec=&#39;</span><span class="p">,</span><span class="n">nelec</span><span class="p">)</span>


<span class="c">#</span>
<span class="c"># 3.4 select &#39;active&#39; orbitals</span>
<span class="c">#</span>
<span class="c"># By reading the orbital images with Jmol, we characterized some of the local</span>
<span class="c"># orbitals</span>
<span class="c">#</span>
<span class="n">a1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">80</span><span class="p">,</span><span class="mi">82</span><span class="p">,</span><span class="mi">83</span><span class="p">,</span><span class="mi">84</span><span class="p">,</span><span class="mi">85</span><span class="p">,</span><span class="mi">86</span><span class="p">]</span> <span class="c"># S-3p = 7</span>
<span class="n">o1</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>  <span class="c"># approximate occupancies, to help obtain the electrons in active space</span>
<span class="n">a2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">87</span><span class="p">,</span><span class="mi">88</span><span class="p">,</span><span class="mi">89</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">91</span><span class="p">,</span><span class="mi">92</span><span class="p">,</span><span class="mi">93</span><span class="p">,</span><span class="mi">94</span><span class="p">,</span><span class="mi">95</span><span class="p">,</span><span class="mi">96</span><span class="p">]</span> <span class="c"># Fe-Mo (3d,4d) = 10</span>
<span class="n">o2</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span>  <span class="c"># approximate occupancies</span>
<span class="n">a3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">97</span><span class="p">,</span><span class="mi">98</span><span class="p">,</span><span class="mi">99</span><span class="p">,</span><span class="mi">101</span><span class="p">,</span><span class="mi">103</span><span class="p">,</span><span class="mi">105</span><span class="p">]</span> <span class="c"># Mo-s + Fe4d = 6</span>
<span class="n">o3</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">6</span>  <span class="c"># approximate occupancies</span>

<span class="c">#</span>
<span class="c"># There are many different choices for active space, here we just demonstrate</span>
<span class="c"># one which is consists of Fe 3d, Mo 4d and S 3p orbitals</span>
<span class="c">#</span>
<span class="c">#==========================</span>
<span class="c"># select &#39;active&#39; orbitals</span>
<span class="c">#==========================</span>
<span class="n">caslst</span> <span class="o">=</span> <span class="n">a1</span><span class="o">+</span><span class="n">a2</span>
<span class="n">norb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">caslst</span><span class="p">)</span>
<span class="n">ne_act</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">o1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="n">o2</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="mi">1</span> <span class="c"># 0,1,2,3,4, High-spin case ms = s</span>
<span class="n">ne_alpha</span> <span class="o">=</span> <span class="n">ne_act</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="n">s</span>
<span class="n">ne_beta</span>  <span class="o">=</span> <span class="n">ne_act</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">s</span>
<span class="n">nalpha</span> <span class="o">=</span> <span class="n">ne_alpha</span>
<span class="n">nbeta</span> <span class="o">=</span> <span class="n">ne_beta</span>
<span class="n">norb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">caslst</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;norb/nacte=&#39;</span><span class="p">,</span><span class="n">norb</span><span class="p">,[</span><span class="n">nalpha</span><span class="p">,</span><span class="n">nbeta</span><span class="p">])</span>


<span class="c">##################################################</span>
<span class="c">#</span>
<span class="c"># 4. DMRG-CASSCF and DMRG-NEVPT2</span>
<span class="c">#</span>
<span class="c">##################################################</span>
<span class="c">#</span>
<span class="c"># Adjust the MPI schedular and scratch directory if needed.</span>
<span class="c"># NOTE the DMRG-NEVPT2 is expensive, it requires about 8 GB memory per processor</span>
<span class="c">#</span>
<span class="c">#from pyscf.dmrgscf import settings</span>
<span class="c">#settings.MPIPREFIX = &#39;srun&#39;</span>
<span class="c">#settings.BLOCKSCRATCHDIR = &#39;/scratch&#39;</span>

<span class="kn">from</span> <span class="nn">pyscf.dmrgscf</span> <span class="kn">import</span> <span class="n">DMRGCI</span><span class="p">,</span> <span class="n">DMRGSCF</span>
<span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">mrpt</span>

<span class="c">#</span>
<span class="c"># Redirect output to another file</span>
<span class="c">#</span>
<span class="n">mol</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="s">&#39;hs_dmrg.out&#39;</span><span class="p">)</span>

<span class="n">mf</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">sfx2c1e</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">(</span><span class="n">mol</span><span class="p">))</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="p">[</span><span class="n">nalpha</span><span class="p">,</span><span class="n">nbeta</span><span class="p">])</span>
<span class="n">mc</span><span class="o">.</span><span class="n">chkfile</span> <span class="o">=</span> <span class="s">&#39;hs_mc.chk&#39;</span>
<span class="n">mc</span><span class="o">.</span><span class="n">max_memory</span> <span class="o">=</span> <span class="mi">30000</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">maxM</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span><span class="o">.</span><span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-6</span>
<span class="n">orbs</span> <span class="o">=</span> <span class="n">mc</span><span class="o">.</span><span class="n">sort_mo</span><span class="p">(</span><span class="n">caslst</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">mc1step</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span>


<span class="c">#</span>
<span class="c"># CASCI-NEVPT2</span>
<span class="c">#</span>
<span class="c"># If DMRG-CASSCF was finished without any problems (eg convergence, wall time</span>
<span class="c"># limits on cluster etc),  one can simply continue with DMRG-NEVPT2</span>
<span class="c">#       mrpt.NEVPT(mc).kernel()</span>
<span class="c">#</span>
<span class="c"># But it&#39;s highly possible that one needs to restore the calculation from</span>
<span class="c"># previous work.  The following is an example to restore the calculation.</span>
<span class="c"># Assuming DMRG-CASSCF has converged and the DMRG temporary files were</span>
<span class="c"># deleted, we just need the DMRG-CASCI calculation with the converged MCSCF</span>
<span class="c"># orbitals to get the DMRG wavefunction.</span>
<span class="c">#</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">mcscf</span><span class="o">.</span><span class="n">CASCI</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="n">norb</span><span class="p">,</span> <span class="p">[</span><span class="n">nalpha</span><span class="p">,</span><span class="n">nbeta</span><span class="p">])</span>
<span class="n">mc</span><span class="o">.</span><span class="n">chkfile</span> <span class="o">=</span> <span class="s">&#39;hs_mc.chk&#39;</span>
<span class="n">mo</span> <span class="o">=</span> <span class="n">scf</span><span class="o">.</span><span class="n">chkfile</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s">&#39;hs_mc.chk&#39;</span><span class="p">,</span> <span class="s">&quot;mcscf/mo_coeff&quot;</span><span class="p">)</span>
<span class="n">mc</span><span class="o">.</span><span class="n">fcisolver</span> <span class="o">=</span> <span class="n">DMRGCI</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span><span class="n">maxM</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span><span class="mf">1e-8</span><span class="p">)</span>
<span class="c">#</span>
<span class="c"># Tune DMRG parameters.  It&#39;s not necessary in most scenario.</span>
<span class="c">#</span>
<span class="c">#mc.fcisolver.outputlevel = 3</span>
<span class="c">#mc.fcisolver.scheduleSweeps = [0, 4, 8, 12, 16, 20, 24, 28, 30, 34]</span>
<span class="c">#mc.fcisolver.scheduleMaxMs  = [200, 400, 800, 1200, 2000, 4000, 3000, 2000, 1000, 500]</span>
<span class="c">#mc.fcisolver.scheduleTols   = [0.0001, 0.0001, 0.0001, 0.0001, 1e-5, 1e-6, 1e-7, 1e-7, 1e-7, 1e-7 ]</span>
<span class="c">#mc.fcisolver.scheduleNoises = [0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0001, 0.0, 0.0, 0.0, 0.0]</span>
<span class="c">#mc.fcisolver.twodot_to_onedot = 38</span>
<span class="c">#mc.fcisolver.maxIter = 50</span>
<span class="n">mc</span><span class="o">.</span><span class="n">casci</span><span class="p">(</span><span class="n">mo</span><span class="p">)</span>

<span class="c">#</span>
<span class="c"># DMRG-NEVPT2</span>
<span class="c">#</span>
<span class="n">mrpt</span><span class="o">.</span><span class="n">NEVPT</span><span class="p">(</span><span class="n">mc</span><span class="p">)</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c">#</span>
<span class="c"># There is also a fast DMRG-NEVPT2 implementation.  See also the example</span>
<span class="c"># pyscf/examples/dmrg/02-dmrg_nevpt2.py</span>
<span class="c">#</span>
<span class="n">mrpt</span><span class="o">.</span><span class="n">NEVPT</span><span class="p">(</span><span class="n">mc</span><span class="p">)</span><span class="o">.</span><span class="n">compress_approx</span><span class="p">()</span><span class="o">.</span><span class="n">kernel</span><span class="p">()</span>

<span class="c">##################################################</span>
<span class="c">#</span>
<span class="c"># Don&#39;t forget to clean up the scratch.  DMRG calculation can produce large</span>
<span class="c"># amount of temporary files.</span>
<span class="c">#</span>
<span class="c">##################################################</span>
</pre></div>
</div>
</div>
<div class="section" id="run-block-standalone">
<h2>Run Block standalone<a class="headerlink" href="#run-block-standalone" title="Permalink to this headline">¶</a></h2>
<p><tt class="docutils literal"><span class="pre">Block</span></tt> program can be run standalone without the PySCF environments.
In PySCF-1.3,  the DMRG interface provides dry run mode to generate the Block
input config <tt class="file docutils literal"><span class="pre">dmrg.conf</span></tt> and the integral file
<tt class="file docutils literal"><span class="pre">FCIDUMP</span></tt>.:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">pyscf</span> <span class="kn">import</span> <span class="n">gto</span><span class="p">,</span> <span class="n">scf</span><span class="p">,</span> <span class="n">dmrgscf</span>
<span class="n">mf</span> <span class="o">=</span> <span class="n">gto</span><span class="o">.</span><span class="n">M</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="s">&quot;N 0 0 0; N 0 0 1&quot;</span><span class="p">,</span> <span class="n">basis</span><span class="o">=</span><span class="s">&quot;ccpvdz&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">scf</span><span class="o">.</span><span class="n">RHF</span><span class="p">)</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="n">mc</span> <span class="o">=</span> <span class="n">dmrgscf</span><span class="o">.</span><span class="n">DMRGSCF</span><span class="p">(</span><span class="n">mf</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">dmrgscf</span><span class="o">.</span><span class="n">dryrun</span><span class="p">(</span><span class="n">mc</span><span class="p">)</span>
</pre></div>
</div>
<p>You can execute Block program in command line:</p>
<div class="highlight-python"><div class="highlight"><pre>mpirun -n 2 block.spin_adapted dmrg.conf &gt; dmrg.out
</pre></div>
</div>
<p>See more examples in Chapter <a class="reference internal" href="examples.html#standalone"><em>Block program as a standalone solver</em></a>.</p>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>cite paper.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Please contact &#8220;Sandeep Sharma&#8221; &lt;<a class="reference external" href="mailto:sanshar&#37;&#52;&#48;gmail&#46;com">sanshar<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt; or &#8220;Garnet Chan&#8221;
&lt;<a class="reference external" href="mailto:gkc1000&#37;&#52;&#48;gmail&#46;com">gkc1000<span>&#64;</span>gmail<span>&#46;</span>com</a>&gt; for Block source code.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="examples.html" title="Block program as a standalone solver"
             >next</a></li>
        <li class="right" >
          <a href="build.html" title="Block Installation"
             >previous</a> |</li>
        <li><a href="index.html">BLOCK 1.5.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, Garnet Kin-Lic Chan.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>